package main

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	descriptor "google.golang.org/protobuf/types/descriptorpb"
)

const (
	bytesPackage          = protogen.GoImportPath("bytes")
	stringsPackage        = protogen.GoImportPath("strings")
	contextPackage        = protogen.GoImportPath("context")
	fmtPackage            = protogen.GoImportPath("fmt")
	ioutilPackage         = protogen.GoImportPath("io/ioutil")
	httpPackage           = protogen.GoImportPath("net/http")
	strconvPackage        = protogen.GoImportPath("strconv")
	jsonpbPackage         = protogen.GoImportPath("github.com/golang/protobuf/jsonpb")
	protoPackage          = protogen.GoImportPath("github.com/golang/protobuf/proto")
	ioPackage             = protogen.GoImportPath("io")
	jsonPackage           = protogen.GoImportPath("encoding/json")
	pathPackage           = protogen.GoImportPath("path")
	urlPackage            = protogen.GoImportPath("net/url")
	hRpcPackage           = protogen.GoImportPath("github.com/cyub/hrpc")
	hRpcCtxsettersPackage = protogen.GoImportPath("github.com/cyub/hrpc/ctxsetters")
)

type generator struct {
	filesHandled int
	genFiles     []*protogen.File
}

func newGenerator() *generator {
	return &generator{}
}

func (ge *generator) Run() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		ge.genFiles = gen.Files
		for idx, file := range gen.Files {
			ge.filesHandled = idx
			ge.generateFile(file, gen)
		}
		return nil
	})
}

func (ge *generator) generateFile(f *protogen.File, p *protogen.Plugin) *protogen.GeneratedFile {
	if len(f.Services) == 0 { // there is no service define in proto file
		return nil
	}
	filename := f.GeneratedFilenamePrefix + ".hrpc.go"
	g := p.NewGeneratedFile(filename, f.GoImportPath)
	// header
	g.P("// Code generated by protoc-gen-hrpc. DO NOT EDIT.")
	g.P("// source: ", f.Proto.GetName())
	g.P()
	g.P("/*")
	g.P("Package ", f.GoPackageName, " is a generated hrpc package.")
	g.P("This code was generated with github.com/cyub/hrpc/cmd/protoc-gen-hrpc ", "v"+version, ".")
	g.P("*/")
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()

	ge.generateFileContent(f, p, g)
	return g
}

func (ge *generator) generateFileContent(f *protogen.File, p *protogen.Plugin, g *protogen.GeneratedFile) {
	ge.generateVersionCheck(g)
	for _, service := range f.Services {
		ge.generateService(g, service)
	}
}

func (ge *generator) generateVersionCheck(g *protogen.GeneratedFile) {
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the hrpc package used in your project.")
	g.P("const _ = ", g.QualifiedGoIdent(hRpcPackage.Ident("HrpcPackageIsVersion1")))
	g.P()
}

func (ge *generator) generateService(g *protogen.GeneratedFile, s *protogen.Service) {
	svcName := s.GoName
	// service interface
	g.P("// ", svcName, " Interface")
	g.P("type ", svcName, " interface {")
	for _, method := range s.Methods {
		g.Annotate(svcName+"."+method.GoName, method.Location)
		g.P(method.Comments.Leading, clientSignature(g, method))
	}
	g.P("}")
	g.P()

	// protobuf client
	ge.generateClient("Protobuf", g, s)
	// json client
	ge.generateClient("JSON", g, s)
	// server handler
	ge.generateServer(g, s)
}

func (ge *generator) generateClient(clientType string, g *protogen.GeneratedFile, s *protogen.Service) {
	svcName := s.GoName
	clientName := svcName + clientType + "Client"
	newClientFuncName := "New" + clientName

	g.P("// ", svcName, "Protobuf Client")
	g.P("type ", unexport(clientName), " struct{")
	g.P("	client HTTPClient")
	g.P("	urls ", "[", len(s.Methods), "]string")
	g.P("	interceptor ", g.QualifiedGoIdent(hRpcPackage.Ident("Interceptor")))
	g.P("	opts ", g.QualifiedGoIdent(hRpcPackage.Ident("ClientOptions")))
	g.P("}")
	g.P()

	g.P("// ", newClientFuncName, "creates a "+clientType+" client that implements the ", svcName, "interface")
	g.P("func ", newClientFuncName,
		"(baseURL string, client HTTPClient, opts ...",
		g.QualifiedGoIdent(hRpcPackage.Ident("ClientOption")),
		") ",
		svcName,
		"{")
	g.P("	if c, ok := client.(*" + g.QualifiedGoIdent(httpPackage.Ident("Client")) + "); ok {")
	g.P("		client = withoutRedirects(c)")
	g.P("	}")
	g.P()

	g.P("	clientOpts := " + g.QualifiedGoIdent(hRpcPackage.Ident("ClientOptions")) + "{}")
	g.P("	for _, o := range opts {")
	g.P("		o(&clientOpts)")
	g.P("	}")
	g.P()

	g.P("	serviceURL := sanitizeBaseURL(baseURL)")
	g.P("	serviceURL += baseServicePath(clientOpts.PathPrefix(), ", `"`+s.Desc.FullName()+`")`)
	g.P("	urls := [", len(s.Methods), "]string{")
	for _, method := range s.Methods {
		g.P(`	serviceURL + "` + method.GoName + `",`)
	}
	g.P("	}")
	g.P("	return &", unexport(clientName), "{")
	g.P("		client: client,")
	g.P("		urls: urls,")
	g.P("		interceptor: ", g.QualifiedGoIdent(hRpcPackage.Ident("ChainInterceptors")), "(clientOpts.Interceptors...),")
	g.P("		opts: clientOpts,")
	g.P("	}")
	g.P("}")
	g.P()

	// generate method
	for i, method := range s.Methods {
		g.P(clientMethodSignature(unexport(clientName), method.GoName, g, method), " {")
		g.P("	ctx = ", g.QualifiedGoIdent(hRpcCtxsettersPackage.Ident("WithPackageName")), "(ctx, \"", s.Desc.Parent().FullName(), "\")")
		g.P("	ctx = ", g.QualifiedGoIdent(hRpcCtxsettersPackage.Ident("WithServiceName")), "(ctx, \""+s.GoName+"\")")
		g.P("	ctx = ", g.QualifiedGoIdent(hRpcCtxsettersPackage.Ident("WithMethodName")), "(ctx, \""+method.GoName+"\")")
		g.P("	caller := c.", "call"+method.GoName)
		g.P("	if c.interceptor != nil {")

		g.P("		caller = func(ctx ", g.QualifiedGoIdent(contextPackage.Ident("Context")),
			", req ", "*"+g.QualifiedGoIdent(method.Input.GoIdent),
			") (", "*"+g.QualifiedGoIdent(method.Output.GoIdent)+", error) {")
		g.P("			resp, err := c.interceptor(")
		g.P("				func(ctx ", g.QualifiedGoIdent(contextPackage.Ident("Context")), ", req interface{}) (interface{}, error) {")
		g.P("					typedReq, ok := req.(*", g.QualifiedGoIdent(method.Input.GoIdent), ")")
		g.P("					if !ok {")
		g.P("						return nil, ", g.QualifiedGoIdent(hRpcPackage.Ident("InternalError")), "(\"failed type assertion req.(*", g.QualifiedGoIdent(method.Input.GoIdent), ") when calling interceptor\")")
		g.P("					}")
		g.P("					return c.call", method.GoName, "(ctx, typedReq)")
		g.P("				},")
		g.P("			)(ctx, req)")
		g.P("			if resp != nil {")
		g.P("				typedResp, ok := resp.(*", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("				if !ok {")
		g.P("					return nil, ", g.QualifiedGoIdent(hRpcPackage.Ident("InternalError")), "(\"failed type assertion resp.(*", g.QualifiedGoIdent(method.Output.GoIdent), ") when calling interceptor\")")
		g.P("				}")
		g.P("				return typedResp, err")
		g.P("			}")
		g.P("			return nil, err")
		g.P("		}")
		g.P("	}")
		g.P("	return caller(ctx, in)")
		g.P("}")
		g.P()

		// actual client method implement
		g.P(clientMethodSignature(unexport(clientName), "call"+method.GoName, g, method), " {")
		g.P("	out := new(", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P("	ctx, err := ", "do"+clientType+"Request", "(ctx, c.client, c.opts.Hooks, ", "c.urls["+strconv.Itoa(i)+"]", ", in, out)")
		g.P("	if err != nil {")
		g.P("		rpcerr, ok := err.(", g.QualifiedGoIdent(hRpcPackage.Ident("Error")), ")")
		g.P("		if !ok {")
		g.P("			rpcerr = ", g.QualifiedGoIdent(hRpcPackage.Ident("InternalErrorWith")), "(err)")
		g.P("		}")
		g.P("		callClientError(ctx, c.opts.Hooks, rpcerr)")
		g.P("		return nil, err")
		g.P("	}")
		g.P("	callClientResponseReceived(ctx, c.opts.Hooks)")
		g.P("	return out, nil")
		g.P("}")
		g.P()
	}
}

func (ge *generator) generateServer(g *protogen.GeneratedFile, s *protogen.Service) {
	svcName := s.GoName
	// define server handler
	g.P("// ", svcName, " Server Handler")
	g.P("type ", unexport(svcName)+"Server", " struct {")
	g.P("	", svcName)
	g.P("	interceptor ", g.QualifiedGoIdent(hRpcPackage.Ident("Interceptor")))
	g.P("	hooks *", g.QualifiedGoIdent(hRpcPackage.Ident("ServerHooks")))
	g.P("	pathPrefix string")
	g.P("	jsonSkipDefaults bool")
	g.P("}")
	g.P()

	// create server Handler
	svcHandler := svcName + "Server"
	g.P("// New", svcHandler, " builds a HrpcServer that can be used as an http.Handler to handle")
	g.P("// HTTP requests that are routed to the right method in the provided svc implementation.")
	g.P("func ", "New"+svcHandler, "(svc ", svcName, ", opts ...interface{}) RPCServer {")
	g.P("	serverOpts := ", g.QualifiedGoIdent(hRpcPackage.Ident("ServerOptions")), "{}")
	g.P("	for _, opt := range opts {")
	g.P("		switch o := opt.(type) {")
	g.P("			case ", g.QualifiedGoIdent(hRpcPackage.Ident("ServerOption")), ":")
	g.P("				o(&serverOpts)")
	g.P("			case *", g.QualifiedGoIdent(hRpcPackage.Ident("ServerHooks")), ":")
	g.P(g.QualifiedGoIdent(hRpcPackage.Ident("WithServerHooks")), "(o)(&serverOpts)")
	g.P("			case nil:")
	g.P("				continue")
	g.P("			default:")
	g.P("				panic(", g.QualifiedGoIdent(fmtPackage.Ident("Sprintf")), "(\"Invalid option type %T on ", "New"+svcName+"Server", "\", o))")
	g.P("		}")
	g.P("	}")

	g.P("	return &", unexport(svcHandler), "{")
	g.P("		", svcName, ": svc,")
	g.P("		pathPrefix: serverOpts.PathPrefix(),")
	g.P("		interceptor: ", g.QualifiedGoIdent(hRpcPackage.Ident("ChainInterceptors")), "(serverOpts.Interceptors...),")
	g.P("		hooks: serverOpts.Hooks,")
	g.P(" 		jsonSkipDefaults: serverOpts.JSONSkipDefaults,")
	g.P("	}")
	g.P("}")
	g.P()

	// server handler writeError method
	g.P("func (s *", unexport(svcHandler), ") writeError(ctx ", g.QualifiedGoIdent(contextPackage.Ident("Context")), ", resp ", g.QualifiedGoIdent(httpPackage.Ident("ResponseWriter")), ", err error) {")
	g.P("	writeError(ctx, resp, err, s.hooks)")
	g.P("}")
	g.P()

	// server handler ServeHTTP method
	g.P("func (s *", unexport(svcHandler), ") ServeHTTP(resp ", g.QualifiedGoIdent(httpPackage.Ident("ResponseWriter")), ", req *", g.QualifiedGoIdent(httpPackage.Ident("Request")), ") {")
	g.P("	ctx := req.Context()")
	g.P("	ctx = ", g.QualifiedGoIdent(hRpcCtxsettersPackage.Ident("WithPackageName")), "(ctx, \"", s.Desc.FullName(), "\")")
	g.P("	ctx = ", g.QualifiedGoIdent(hRpcCtxsettersPackage.Ident("WithServiceName")), "(ctx, \"", s.GoName, "\")")
	g.P("	ctx = ", g.QualifiedGoIdent(hRpcCtxsettersPackage.Ident("WithResponseWriter")), "(ctx, resp)")
	g.P()
	g.P("	var err error")
	g.P("	ctx, err = callRequestReceived(ctx, s.hooks)")
	g.P("	if err != nil {")
	g.P("		s.writeError(ctx, resp, err)")
	g.P("		return")
	g.P("	}")
	g.P()
	g.P("	if req.Method != \"POST\" {")
	g.P("		msg := ", g.QualifiedGoIdent(fmtPackage.Ident("Sprintf")), "(\"unsupported method %q (only POST is allowed)\", req.Method)")
	g.P("		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))")
	g.P("		return")
	g.P("	}")
	g.P()

	g.P("	prefix, pkgService, method := parseRPCPath(req.URL.Path)")
	g.P("	if pkgService != \"", s.Desc.FullName(), "\" {")
	g.P("		msg := ", g.QualifiedGoIdent(fmtPackage.Ident("Sprintf")), "(\"no handler for path %q\", req.URL.Path)")
	g.P("		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))")
	g.P("		return")
	g.P("	}")
	g.P()

	g.P("	if prefix != s.pathPrefix {")
	g.P("		msg := ", g.QualifiedGoIdent(fmtPackage.Ident("Sprintf")), "(\"invalid path prefix %q, expected %q, on path %q\", prefix, s.pathPrefix, req.URL.Path)")
	g.P("		s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))")
	g.P("		return")
	g.P("	}")
	g.P()

	g.P("	switch method {")
	for _, method := range s.Methods {
		g.P("		case \"", method.GoName, "\":")
		g.P("			s.serve", method.GoName, "(ctx, resp, req)")
		g.P("			return")
	}
	g.P("		default:")
	g.P("			msg := fmt.Sprintf(\"no handler for path %q\", req.URL.Path)")
	g.P("			s.writeError(ctx, resp, badRouteError(msg, req.Method, req.URL.Path))")
	g.P("			return")
	g.P("	}")
	g.P("}")
	g.P()

	// serve method
	for _, method := range s.Methods {
		ge.generateServeMethod(g, s, method)
	}

	idx := 0
	genFile := ge.genFiles[ge.filesHandled]
	for i, service := range genFile.Services {
		if s.Desc.FullName().Name() == service.Desc.FullName().Name() {
			idx = i
			break
		}
	}
	// server handler ServiceDescriptor method
	g.P("func (s *", unexport(svcHandler), ") ServiceDescriptor() ([]byte, int) {")
	g.P("	return hrpcFileDescriptor", ge.filesHandled, ",", idx)
	g.P("}")
	g.P()

	// server handler ProtocGenHrpcVersion method
	g.P("func (s *", unexport(svcHandler), ") ProtocGenHrpcVersion() string {")
	g.P("	return \"v1.2.0\"")
	g.P("}")
	g.P()

	// server handler PathPrefix method
	g.P("func (s *", unexport(svcHandler), ") PathPrefix() string {")
	g.P("	return baseServicePath(s.pathPrefix, \"", s.Desc.FullName(), "\")")
	g.P("}")
	g.P()

	// generate command function  or type and so on
	ge.generateCommon(g)
	// generate profile descriptor
	ge.generateProtoFileDescriptor(g, s)
}

func (ge *generator) generateServeMethod(gen *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	gen.P("func (s *", unexport(service.GoName)+"Server", ") ",
		"serve"+method.GoName,
		"(ctx ", gen.QualifiedGoIdent(contextPackage.Ident("Context")),
		", resp ",
		gen.QualifiedGoIdent(httpPackage.Ident("ResponseWriter")),
		", req *",
		gen.QualifiedGoIdent(httpPackage.Ident("Request")),
		") {",
	)

	gen.P("header := req.Header.Get(\"Content-Type\")")
	gen.P("	i := ", gen.QualifiedGoIdent(stringsPackage.Ident("Index")), "(header, \";\")")
	gen.P("	if i == -1 {")
	gen.P("		i = len(header)")
	gen.P("	}")
	gen.P("	switch ", gen.QualifiedGoIdent(stringsPackage.Ident("TrimSpace")), "(", gen.QualifiedGoIdent(stringsPackage.Ident("ToLower")), "(header[:i])) {")
	gen.P("		case \"application/json\":")
	gen.P("			s.", "serve"+method.GoName+"JSON", "(ctx, resp, req)")
	gen.P("		case \"application/protobuf\":")
	gen.P("			s.", "serve"+method.GoName+"Protobuf", "(ctx, resp, req)")
	gen.P("		default:")
	gen.P("			msg := ", gen.QualifiedGoIdent(fmtPackage.Ident("Sprintf")), "(\"unexpected Content-Type: %q\", req.Header.Get(\"Content-Type\"))")
	gen.P("			rpcerr := badRouteError(msg, req.Method, req.URL.Path)")
	gen.P("			s.writeError(ctx, resp, rpcerr)")
	gen.P("	}")
	gen.P("}")
	gen.P()

	fn := func(clientType string, gen *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
		gen.P("func (s *", unexport(service.GoName)+"Server", ") ", "serve"+method.GoName+clientType, "(ctx ", gen.QualifiedGoIdent(contextPackage.Ident("Context")), ", resp ", gen.QualifiedGoIdent(httpPackage.Ident("ResponseWriter")), ", req *", gen.QualifiedGoIdent(httpPackage.Ident("Request")), ") {")
		gen.P("	var err error")
		gen.P("	ctx = ", gen.QualifiedGoIdent(hRpcCtxsettersPackage.Ident("WithMethodName")), "(ctx, \"", method.GoName, "\")")
		gen.P("	ctx, err = callRequestRouted(ctx, s.hooks)")
		gen.P("	if err != nil {")
		gen.P("		s.writeError(ctx, resp, err)")
		gen.P("		return")
		gen.P("	}")

		if clientType == "JSON" {
			gen.P("	reqContent := new(", gen.QualifiedGoIdent(method.Input.GoIdent), ")")
			gen.P("	unmarshaler := ", gen.QualifiedGoIdent(jsonpbPackage.Ident("Unmarshaler")), "{AllowUnknownFields: true}")
			gen.P("	if err = unmarshaler.Unmarshal(req.Body, reqContent); err != nil {")
			gen.P("		s.writeError(ctx, resp, malformedRequestError(\"the json request could not be decoded\"))")
			gen.P("		return")
			gen.P("	}")
		} else {
			gen.P("	buf, err := ", gen.QualifiedGoIdent(ioutilPackage.Ident("ReadAll")), "(req.Body)")
			gen.P("	if err != nil {")
			gen.P("		s.writeError(ctx, resp, wrapInternal(err, \"failed to read request body\"))")
			gen.P("		return")
			gen.P("	}")
			gen.P("	reqContent := new(", gen.QualifiedGoIdent(method.Input.GoIdent), ")")
			gen.P("	if err = ", gen.QualifiedGoIdent(protoPackage.Ident("Unmarshal")), "(buf, reqContent); err != nil {")
			gen.P("		s.writeError(ctx, resp, malformedRequestError(\"the protobuf request could not be decoded\"))")
			gen.P("		return")
			gen.P("	}")
		}

		gen.P("	handler := s.", service.GoName, ".", method.GoName)
		gen.P("	if s.interceptor != nil {")
		gen.P("		handler = func(ctx ", gen.QualifiedGoIdent(contextPackage.Ident("Context")), ", req *", gen.QualifiedGoIdent(method.Input.GoIdent), ") (*", gen.QualifiedGoIdent(method.Output.GoIdent), ", error) {")
		gen.P("			resp, err := s.interceptor(")
		gen.P("				func(ctx ", gen.QualifiedGoIdent(contextPackage.Ident("Context")), ", req interface{}) (interface{}, error) {")
		gen.P("					typedReq, ok := req.(*", gen.QualifiedGoIdent(method.Input.GoIdent), ")")
		gen.P("					if !ok {")
		gen.P("						return nil, ", gen.QualifiedGoIdent(hRpcPackage.Ident("InternalError")), "(\"failed type assertion req.(*", gen.QualifiedGoIdent(method.Input.GoIdent), ") when calling interceptor\")")
		gen.P("					}")
		gen.P("					return ", "s."+service.GoName+"."+method.GoName, "(ctx, typedReq)")
		gen.P("				},")
		gen.P("			)(ctx, req)")
		gen.P("			if resp != nil {")
		gen.P("				typedResp, ok := resp.(*", gen.QualifiedGoIdent(method.Output.GoIdent), ")")
		gen.P("				if !ok {")
		gen.P("					return nil, ", gen.QualifiedGoIdent(hRpcPackage.Ident("InternalError")), "(\"failed type assertion resp.(*", gen.QualifiedGoIdent(method.Output.GoIdent), ") when calling interceptor\")")
		gen.P("				}")
		gen.P("				return typedResp, err")
		gen.P("			}")
		gen.P("			return nil, err")
		gen.P("		}")
		gen.P("	}")
		gen.P()
		gen.P("	var respContent *", gen.QualifiedGoIdent(method.Output.GoIdent))
		gen.P("	func() {")
		gen.P("	defer ensurePanicResponses(ctx, resp, s.hooks)")
		gen.P("		respContent, err = handler(ctx, reqContent)")
		gen.P("	}()")
		gen.P("	if err != nil {")
		gen.P("		s.writeError(ctx, resp, err)")
		gen.P("		return")
		gen.P("	}")
		gen.P("	if respContent == nil {")
		gen.P("		s.writeError(ctx, resp, ", gen.QualifiedGoIdent(hRpcPackage.Ident("InternalError")), "(\"received a nil *", gen.QualifiedGoIdent(method.Output.GoIdent), " and nil error while calling ", method.GoName, ". nil responses are not supported\"))")
		gen.P("		return")
		gen.P("	}")
		gen.P("	ctx = callResponsePrepared(ctx, s.hooks)")

		if clientType == "JSON" {
			gen.P("	var buf ", gen.QualifiedGoIdent(bytesPackage.Ident("Buffer")))
			gen.P("	marshaler := &", gen.QualifiedGoIdent(jsonpbPackage.Ident("Marshaler")), "{OrigName: true, EmitDefaults: !s.jsonSkipDefaults}")
			gen.P("	if err = marshaler.Marshal(&buf, respContent); err != nil {")
			gen.P("		s.writeError(ctx, resp, wrapInternal(err, \"failed to marshal json response\"))")
			gen.P("		return")
			gen.P("	}")
			gen.P("	respBytes := buf.Bytes()")
			gen.P("	resp.Header().Set(\"Content-Type\", \"application/json\")")
		} else {
			gen.P("	respBytes, err := ", gen.QualifiedGoIdent(protoPackage.Ident("Marshal")), "(respContent)")
			gen.P("	if err != nil {")
			gen.P("		s.writeError(ctx, resp, wrapInternal(err, \"failed to marshal proto response\"))")
			gen.P("		return")
			gen.P("	}")
			gen.P("	resp.Header().Set(\"Content-Type\", \"application/protobuf\")")
		}

		gen.P("	ctx = ", gen.QualifiedGoIdent(hRpcCtxsettersPackage.Ident("WithStatusCode")), "(ctx, ", gen.QualifiedGoIdent(httpPackage.Ident("StatusOK")), ")")
		gen.P("	resp.Header().Set(\"Content-Length\", ", gen.QualifiedGoIdent(strconvPackage.Ident("Itoa")), "(len(respBytes)))")
		gen.P("	resp.WriteHeader(", gen.QualifiedGoIdent(httpPackage.Ident("StatusOK")), ")")
		gen.P("	if n, err := resp.Write(respBytes); err != nil {")
		gen.P("		msg := ", gen.QualifiedGoIdent(fmtPackage.Ident("Sprintf")), "(\"failed to write response, %d of %d bytes written: %s\", n, len(respBytes), err.Error())")
		gen.P("		rpcerr := ", gen.QualifiedGoIdent(hRpcPackage.Ident("NewError")), "(", gen.QualifiedGoIdent(hRpcPackage.Ident("Unknown")), ", msg)")
		gen.P("		ctx = callError(ctx, s.hooks, rpcerr)")
		gen.P("	}")
		gen.P("	callResponseSent(ctx, s.hooks)")
		gen.P("}")
		gen.P()
	}
	fn("JSON", gen, service, method)
	fn("Protobuf", gen, service, method)
}

func (ge *generator) generateCommon(g *protogen.GeneratedFile) {
	gen := func(g *protogen.GeneratedFile, tpl string, idents ...protogen.GoIdent) {
		replace := make([]interface{}, 0, len(idents))
		for _, ident := range idents {
			replace = append(replace, g.QualifiedGoIdent(ident))
		}
		g.P(fmt.Sprintf(tpl, replace...))
	}

	// RPCServer interface
	gen(g, RPCServerTPL)
	// HTTPClient interface
	gen(g, HTTPClientTPL, httpPackage.Ident("Request"), httpPackage.Ident("Response"))
	// sanitizeBaseURL function
	gen(g, sanitizeBaseURLTPL, urlPackage.Ident("Parse"))
	// withoutRedirects function
	gen(g, withoutRedirectsTPL, httpPackage.Ident("Client"),
		httpPackage.Ident("Client"),
		httpPackage.Ident("Request"),
		httpPackage.Ident("Request"),
		httpPackage.Ident("ErrUseLastResponse"),
	)
	// baseServicePath function
	gen(g, baseServicePathTPL, pathPackage.Ident("Join"))
	// doProtobufRequest function
	gen(g, doProtobufRequestTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ClientHooks"),
		protoPackage.Ident("Message"),
		contextPackage.Ident("Context"),
		protoPackage.Ident("Marshal"),
		bytesPackage.Ident("NewBuffer"),
		ioutilPackage.Ident("ReadAll"),
		protoPackage.Ident("Unmarshal"),
	)
	// doJSONRequest function
	gen(g, doJSONRequestTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ClientHooks"),
		protoPackage.Ident("Message"),
		contextPackage.Ident("Context"),
		bytesPackage.Ident("NewBuffer"),
		jsonpbPackage.Ident("Marshaler"),
		jsonpbPackage.Ident("Unmarshaler"),
	)
	// callRequestReceived function
	gen(g, callRequestReceivedTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ServerHooks"),
		contextPackage.Ident("Context"),
	)
	// callRequestRouted function
	gen(g, callRequestRoutedTPL,
		contextPackage.Ident("Context"),
		hRpcPackage.Ident("ServerHooks"),
		contextPackage.Ident("Context"),
	)
	// callResponsePrepared function
	gen(g, callResponsePreparedTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ServerHooks"),
		contextPackage.Ident("Context"),
	)
	// callResponseSent function
	gen(g, callResponseSentTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ServerHooks"))
	// callError function
	gen(g, callErrorTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ServerHooks"),
		hRpcPackage.Ident("Error"),
		contextPackage.Ident("Context"),
	)
	// callClientResponseReceived function
	gen(g, callClientResponseReceivedTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ClientHooks"),
	)
	// callClientRequestPrepared function
	gen(g, callClientRequestPreparedTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ClientHooks"),
		httpPackage.Ident("Request"),
		contextPackage.Ident("Context"),
	)
	// callClientError function
	gen(g, callClientErrorTPL, contextPackage.Ident("Context"),
		hRpcPackage.Ident("ClientHooks"),
		hRpcPackage.Ident("Error"),
	)
	// WriteError function
	gen(g, WriteErrorTPL, httpPackage.Ident("ResponseWriter"), contextPackage.Ident("Background"))
	// writeError function
	gen(g, writeErrorTPL, contextPackage.Ident("Context"),
		httpPackage.Ident("ResponseWriter"),
		hRpcPackage.Ident("ServerHooks"),
		hRpcPackage.Ident("Error"),
		hRpcPackage.Ident("InternalErrorWith"),
		hRpcPackage.Ident("ServerHTTPStatusFromErrorCode"),
		hRpcCtxsettersPackage.Ident("WithStatusCode"),
	)
	// parseRPCPath function
	gen(g, parseRPCPathTPL, stringsPackage.Ident("Split"), stringsPackage.Ident("Join"))
	// getCustomHTTPReqHeaders function
	gen(g, getCustomHTTPReqHeadersTPL, contextPackage.Ident("Context"),
		httpPackage.Ident("Header"),
		hRpcPackage.Ident("HTTPRequestHeaders"),
		httpPackage.Ident("Header"),
	)
	// newRequest function
	gen(g, newRequestTPL, contextPackage.Ident("Context"),
		ioPackage.Ident("Reader"),
		httpPackage.Ident("Request"),
		httpPackage.Ident("NewRequest"),
	)
	// rpcErrJSON define
	gen(g, rpcErrJSONTPL, hRpcPackage.Ident("Error"),
		jsonPackage.Ident("Marshal"),
		hRpcPackage.Ident("Internal"),
	)
	// errorFromResponse function
	gen(g, errorFromResponseTPL, httpPackage.Ident("Response"),
		hRpcPackage.Ident("Error"),
		httpPackage.Ident("StatusText"),
		fmtPackage.Ident("Sprintf"),
		ioutilPackage.Ident("ReadAll"),
		jsonPackage.Ident("NewDecoder"),
		fmtPackage.Ident("Sprintf"),
		hRpcPackage.Ident("ErrorCode"),
		hRpcPackage.Ident("IsValidErrorCode"),
		hRpcPackage.Ident("InternalError"),
		hRpcPackage.Ident("NewError"),
	)
	// rpcErrorFromIntermediary function
	gen(g, rpcErrorFromIntermediaryTPL, hRpcPackage.Ident("Error"),
		hRpcPackage.Ident("ErrorCode"),
		hRpcPackage.Ident("Internal"),
		hRpcPackage.Ident("Internal"),
		hRpcPackage.Ident("Unauthenticated"),
		hRpcPackage.Ident("PermissionDenied"),
		hRpcPackage.Ident("BadRoute"),
		hRpcPackage.Ident("ResourceExhausted"),
		hRpcPackage.Ident("Unavailable"),
		hRpcPackage.Ident("Unknown"),
		hRpcPackage.Ident("NewError"),
		strconvPackage.Ident("Itoa"),
	)
	// isHTTPRedirect function
	gen(g, isHTTPRedirectTPL)
	// wrapInternal function
	gen(g, wrapInternalTPL, hRpcPackage.Ident("Error"),
		hRpcPackage.Ident("InternalErrorWith"))
	// wrappedError defined
	gen(g, wrappedErrorTPL)
	// ensurePanicResponses function
	gen(g, ensurePanicResponsesTPL, contextPackage.Ident("Context"),
		httpPackage.Ident("ResponseWriter"),
		hRpcPackage.Ident("ServerHooks"),
		httpPackage.Ident("Flusher"),
	)
	// errFromPanic function
	gen(g, errFromPanicTPL, fmtPackage.Ident("Errorf"))
	// internalWithCause define
	gen(g, internalWithCauseTPL, hRpcPackage.Ident("ErrorCode"),
		hRpcPackage.Ident("Internal"),
		hRpcPackage.Ident("Error"),
	)
	// malformedRequestError function
	gen(g, malformedRequestErrorTPL, hRpcPackage.Ident("Error"),
		hRpcPackage.Ident("NewError"),
		hRpcPackage.Ident("Malformed"),
	)
	// badRouteError function
	gen(g, badRouteErrorTPL, hRpcPackage.Ident("Error"),
		hRpcPackage.Ident("NewError"),
		hRpcPackage.Ident("BadRoute"),
	)
}

func (ge *generator) generateProtoFileDescriptor(g *protogen.GeneratedFile, s *protogen.Service) {
	genFile := ge.genFiles[ge.filesHandled]
	pb := proto.Clone(genFile.Proto).(*descriptor.FileDescriptorProto)
	pb.SourceCodeInfo = nil
	b, err := proto.Marshal(pb)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	w, _ := gzip.NewWriterLevel(&buf, gzip.BestCompression)
	w.Write(b)
	w.Close()
	b = buf.Bytes()

	g.P()
	g.P("var ", "hrpcFileDescriptor", ge.filesHandled, " = []byte{")
	g.P("	// ", fmt.Sprintf("%d", len(b)), " bytes of a gzipped FileDescriptorProto")
	for len(b) > 0 {
		n := 16
		if n > len(b) {
			n = len(b)
		}

		s := ""
		for _, c := range b[:n] {
			s += fmt.Sprintf("0x%02x,", c)
		}
		g.P(`	`, s)

		b = b[n:]
	}
	g.P("}")
}

func unexport(name string) string {
	return strings.ToLower(name[0:1]) + name[1:]
}

func clientSignature(gen *protogen.GeneratedFile, method *protogen.Method) string {
	signature := method.GoName + "(" + gen.QualifiedGoIdent(contextPackage.Ident("Context")) + ","
	signature += "*" + gen.QualifiedGoIdent(method.Input.GoIdent) + ")"
	signature += " (*" + gen.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	return signature
}

func clientMethodSignature(receiver, methodName string, gen *protogen.GeneratedFile, method *protogen.Method) string {
	signature := "func (c *" + receiver + ") " + methodName
	signature += "(ctx " + gen.QualifiedGoIdent(contextPackage.Ident("Context")) + ","
	signature += " in *" + gen.QualifiedGoIdent(method.Input.GoIdent) + ") ("
	signature += "*" + gen.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	return signature
}

var RPCServerTPL = `
// RPCServer is the interface generated server structs will support: they're
// HTTP handlers with additional methods for accessing metadata about the service.
type RPCServer interface {
	http.Handler

	// ServiceDescriptor returns gzipped bytes describing the .proto file that
	// this service was generated from. Once unzipped, the bytes can be
	// unmarshalled as a
	// github.com/golang/protobuf/protoc-gen-go/descriptor.FileDescriptorProto.
	//
	// The returned integer is the index of this particular service within that
	// FileDescriptorProto's 'Service' slice of ServiceDescriptorProtos. This is a
	// low-level field, expected to be used for reflection.
	ServiceDescriptor() ([]byte, int)

	// ProtocGenHrpcVersion is the semantic version string of the version of hrpc used to generate this file.
	ProtocGenHrpcVersion() string

	// PathPrefix returns the HTTP URL path prefix for all methods handled by this service.
	PathPrefix() string
}
`

var HTTPClientTPL = `
// HTTPClient is the interface used by generated clients to send HTTP requests.
type HTTPClient interface {
	Do(req *%s) (*%s, error)
}
`

var sanitizeBaseURLTPL = `
func sanitizeBaseURL(baseURL string) string {
	u, err := %s(baseURL)
	if err != nil {
		return baseURL // invalid URL will fail later when making requests
	}
	if u.Scheme == "" {
		u.Scheme = "http"
	}
	return u.String()
}
`

var withoutRedirectsTPL = `
// withoutRedirects makes sure that the POST request can not be redirected.
func withoutRedirects(in *%s) *%s {
	copy := *in
	copy.CheckRedirect = func(req *%s, via []*%s) error {
		if in.CheckRedirect != nil {
			// Run the input's redirect if it exists, in case it has side effects, but ignore any error it
			// returns, since we want to use ErrUseLastResponse.
			err := in.CheckRedirect(req, via)
			_ = err // Silly, but this makes sure generated code passes errcheck -blank, which some people use.
		}
		return %s
	}
	return &copy
}
`

var baseServicePathTPL = `
func baseServicePath(prefix, serviceFullName string) string {
	return %s("/", prefix, serviceFullName) + "/"
}
`

var doProtobufRequestTPL = `
// doProtobufRequest makes a Protobuf request to the remote rpc service.
func doProtobufRequest(ctx %s, client HTTPClient, hooks *%s, url string, in, out %s) (_ %s, err error) {
	reqBodyBytes, err := %s(in)
	if err != nil {
		return ctx, wrapInternal(err, "failed to marshal proto request")
	}
	reqBody := %s(reqBodyBytes)
	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	req, err := newRequest(ctx, url, reqBody, "application/protobuf")
	if err != nil {
		return ctx, wrapInternal(err, "could not build request")
	}
	ctx, err = callClientRequestPrepared(ctx, hooks, req)
	if err != nil {
		return ctx, err
	}

	req = req.WithContext(ctx)
	resp, err := client.Do(req)
	if err != nil {
		return ctx, wrapInternal(err, "failed to do request")
	}

	defer func() {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = wrapInternal(cerr, "failed to close response body")
		}
	}()

	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	if resp.StatusCode != 200 {
		return ctx, errorFromResponse(resp)
	}

	respBodyBytes, err := %s(resp.Body)
	if err != nil {
		return ctx, wrapInternal(err, "failed to read response body")
	}
	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	if err = %s(respBodyBytes, out); err != nil {
		return ctx, wrapInternal(err, "failed to unmarshal proto response")
	}
	return ctx, nil
}
`

var doJSONRequestTPL = `
// doJSONRequest makes a JSON request to the remote rpc service.
func doJSONRequest(ctx %s, client HTTPClient, hooks *%s, url string, in, out %s) (_ %s, err error) {
	reqBody := %s(nil)
	marshaler := &%s{OrigName: true}
	if err = marshaler.Marshal(reqBody, in); err != nil {
		return ctx, wrapInternal(err, "failed to marshal json request")
	}
	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	req, err := newRequest(ctx, url, reqBody, "application/json")
	if err != nil {
		return ctx, wrapInternal(err, "could not build request")
	}
	ctx, err = callClientRequestPrepared(ctx, hooks, req)
	if err != nil {
		return ctx, err
	}

	req = req.WithContext(ctx)
	resp, err := client.Do(req)
	if err != nil {
		return ctx, wrapInternal(err, "failed to do request")
	}

	defer func() {
		cerr := resp.Body.Close()
		if err == nil && cerr != nil {
			err = wrapInternal(cerr, "failed to close response body")
		}
	}()

	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}

	if resp.StatusCode != 200 {
		return ctx, errorFromResponse(resp)
	}

	unmarshaler := %s{AllowUnknownFields: true}
	if err = unmarshaler.Unmarshal(resp.Body, out); err != nil {
		return ctx, wrapInternal(err, "failed to unmarshal json response")
	}
	if err = ctx.Err(); err != nil {
		return ctx, wrapInternal(err, "aborted because context was done")
	}
	return ctx, nil
}
`

var callRequestReceivedTPL = `
// Call rpc.ServerHooks.RequestReceived if the hook is available
func callRequestReceived(ctx %s, h *%s) (%s, error) {
	if h == nil || h.RequestReceived == nil {
		return ctx, nil
	}
	return h.RequestReceived(ctx)
}
`

var callRequestRoutedTPL = `
// Call rpc.ServerHooks.RequestRouted if the hook is available
func callRequestRouted(ctx %s, h *%s) (%s, error) {
	if h == nil || h.RequestRouted == nil {
		return ctx, nil
	}
	return h.RequestRouted(ctx)
}
`

var callResponsePreparedTPL = `
// Call rpc.ServerHooks.ResponsePrepared if the hook is available
func callResponsePrepared(ctx %s, h *%s) %s {
	if h == nil || h.ResponsePrepared == nil {
		return ctx
	}
	return h.ResponsePrepared(ctx)
}
`

var callResponseSentTPL = `
// Call rpc.ServerHooks.ResponseSent if the hook is available
func callResponseSent(ctx %s, h *%s) {
	if h == nil || h.ResponseSent == nil {
		return
	}
	h.ResponseSent(ctx)
}
`

var callErrorTPL = `
// Call rpc.ServerHooks.Error if the hook is available
func callError(ctx %s, h *%s, err %s) %s {
	if h == nil || h.Error == nil {
		return ctx
	}
	return h.Error(ctx, err)
}
`

var callClientResponseReceivedTPL = `
func callClientResponseReceived(ctx %s, h *%s) {
	if h == nil || h.ResponseReceived == nil {
		return
	}
	h.ResponseReceived(ctx)
}
`

var callClientRequestPreparedTPL = `
func callClientRequestPrepared(ctx %s, h *%s, req *%s) (%s, error) {
	if h == nil || h.RequestPrepared == nil {
		return ctx, nil
	}
	return h.RequestPrepared(ctx, req)
}
`

var callClientErrorTPL = `
func callClientError(ctx %s, h *%s, err %s) {
	if h == nil || h.Error == nil {
		return
	}
	h.Error(ctx, err)
}
`

var WriteErrorTPL = `
// WriteError writes an HTTP response with a valid rpc error format (code, msg, meta).
func WriteError(resp %s, err error) {
	writeError(%s(), resp, err, nil)
}
`

var writeErrorTPL = `
// writeError writes rpc errors in the response and triggers hooks.
func writeError(ctx %s, resp %s, err error, hooks *%s) {
	rpcerr, ok := err.(%s)
	if !ok {
		rpcerr = %s(err)
	}

	statusCode := %s(rpcerr.Code())
	ctx = %s(ctx, statusCode)
	ctx = callError(ctx, hooks, rpcerr)

	respBody := marshalErrorToJSON(rpcerr)

	resp.Header().Set("Content-Type", "application/json") // Error responses are always JSON
	resp.Header().Set("Content-Length", strconv.Itoa(len(respBody)))
	resp.WriteHeader(statusCode) // set HTTP status code and send response

	_, writeErr := resp.Write(respBody)
	if writeErr != nil {
		_ = writeErr
	}

	callResponseSent(ctx, hooks)
}
`

var parseRPCPathTPL = `
// parseRPCPath extracts path components form a valid rpc route.
// Expected format: "[<prefix>]/<package>.<Service>/<Method>"
func parseRPCPath(path string) (string, string, string) {
	parts := %s(path, "/")
	if len(parts) < 2 {
		return "", "", ""
	}
	method := parts[len(parts)-1]
	pkgService := parts[len(parts)-2]
	prefix := %s(parts[0:len(parts)-2], "/")
	return prefix, pkgService, method
}
`

var getCustomHTTPReqHeadersTPL = `
// getCustomHTTPReqHeaders retrieves a copy of any headers that are set in
// a context through the rpc.WithHTTPRequestHeaders function.
// If there are no headers set, or if they have the wrong type, nil is returned.
func getCustomHTTPReqHeaders(ctx %s) %s {
	header, ok := %s(ctx)
	if !ok || header == nil {
		return nil
	}
	copied := make(%s)
	for k, vv := range header {
		if vv == nil {
			copied[k] = nil
			continue
		}
		copied[k] = make([]string, len(vv))
		copy(copied[k], vv)
	}
	return copied
}
`

var newRequestTPL = `
// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx %s, url string, reqBody %s, contentType string) (*%s, error) {
	req, err := %s("POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if customHeader := getCustomHTTPReqHeaders(ctx); customHeader != nil {
		req.Header = customHeader
	}
	req.Header.Set("Accept", contentType)
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Hrpc-Version", "v1.2.0")
	return req, nil
}
`

var rpcErrJSONTPL = `
// JSON serialization for errors
type rpcErrJSON struct {
	Code string            ` + "`json:\"code\"`" + `
	Msg  string            ` + "`json:\"msg\"`" + `
	Meta map[string]string ` + "`json:\"meta,omitempty\"`" + `
}

// marshalErrorToJSON returns JSON from a rpc.Error, that can be used as HTTP error response body.
// If serialization fails, it will use a descriptive Internal error instead.
func marshalErrorToJSON(rpcerr %s) []byte {
	// make sure that msg is not too large
	msg := rpcerr.Msg()
	if len(msg) > 1e6 {
		msg = msg[:1e6]
	}

	tj := rpcErrJSON{
		Code: string(rpcerr.Code()),
		Msg:  msg,
		Meta: rpcerr.MetaMap(),
	}

	buf, err := %s(&tj)
	if err != nil {
		buf = []byte("{\"type\": \"" + %s + "\", \"msg\": \"There was an error but it could not be serialized into JSON\"}") // fallback
	}

	return buf
}
`

var errorFromResponseTPL = `
// errorFromResponse builds a rpc.Error from a non-200 HTTP response.
func errorFromResponse(resp *%s) %s {
	statusCode := resp.StatusCode
	statusText := %s(statusCode)

	if isHTTPRedirect(statusCode) {
		location := resp.Header.Get("Location")
		msg := %s("unexpected HTTP status code %%d %%q received, Location=%%q", statusCode, statusText, location)
		return rpcErrorFromIntermediary(statusCode, msg, location)
	}

	respBodyBytes, err := %s(resp.Body)
	if err != nil {
		return wrapInternal(err, "failed to read server error response body")
	}

	var tj rpcErrJSON
	dec := %s(bytes.NewReader(respBodyBytes))
	dec.DisallowUnknownFields()
	if err := dec.Decode(&tj); err != nil || tj.Code == "" {
		// Invalid JSON response; it must be an error from an intermediary.
		msg := %s("Error from intermediary with HTTP status code %%d %%q", statusCode, statusText)
		return rpcErrorFromIntermediary(statusCode, msg, string(respBodyBytes))
	}

	errorCode := %s(tj.Code)
	if !%s(errorCode) {
		msg := "invalid type returned from server error response: " + tj.Code
		return %s(msg).WithMeta("body", string(respBodyBytes))
	}

	rpcerr := %s(errorCode, tj.Msg)
	for k, v := range tj.Meta {
		rpcerr = rpcerr.WithMeta(k, v)
	}
	return rpcerr
}
`

var rpcErrorFromIntermediaryTPL = `
// rpcErrorFromIntermediary maps HTTP errors from non-rpc sources to rpc errors.
// The mapping is similar to gRPC: https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.
func rpcErrorFromIntermediary(status int, msg string, bodyOrLocation string) %s{
	var code %s
	if isHTTPRedirect(status) { // 3xx
		code = %s
	} else {
		switch status {
		case 400: // Bad Request
			code = %s
		case 401: // Unauthorized
			code = %s
		case 403: // Forbidden
			code = %s
		case 404: // Not Found
			code = %s
		case 429: // Too Many Requests
			code = %s
		case 502, 503, 504: // Bad Gateway, Service Unavailable, Gateway Timeout
			code = %s
		default: // All other codes
			code = %s
		}
	}

	rpcerr := %s(code, msg)
	rpcerr = rpcerr.WithMeta("http_error_from_intermediary", "true") // to easily know if this error was from intermediary
	rpcerr = rpcerr.WithMeta("status_code", %s(status))
	if isHTTPRedirect(status) {
		rpcerr = rpcerr.WithMeta("location", bodyOrLocation)
	} else {
		rpcerr = rpcerr.WithMeta("body", bodyOrLocation)
	}
	return rpcerr
}
`

var isHTTPRedirectTPL = `
func isHTTPRedirect(status int) bool {
	return status >= 300 && status <= 399
}
`

var wrapInternalTPL = `
// wrapInternal wraps an error with a prefix as an Internal error.
// The original error cause is accessible by github.com/pkg/errors.Cause.
func wrapInternal(err error, prefix string) %s {
	return %s(&wrappedError{prefix: prefix, cause: err})
}
`

var wrappedErrorTPL = `
type wrappedError struct {
	prefix string
	cause  error
}

func (e *wrappedError) Error() string { return e.prefix + ": " + e.cause.Error() }
func (e *wrappedError) Unwrap() error { return e.cause } // for go1.13 + errors.Is/As
func (e *wrappedError) Cause() error  { return e.cause } // for github.com/pkg/errors
`

var ensurePanicResponsesTPL = `
// ensurePanicResponses makes sure that rpc methods causing a panic still result in a rpc Internal
// error response (status 500), and error hooks are properly called with the panic wrapped as an error.
// The panic is re-raised so it can be handled normally with middleware.
func ensurePanicResponses(ctx %s, resp %s, hooks *%s) {
	if r := recover(); r != nil {
		// Wrap the panic as an error so it can be passed to error hooks.
		// The original error is accessible from error hooks, but not visible in the response.
		err := errFromPanic(r)
		rpcerr := &internalWithCause{msg: "Internal service panic", cause: err}
		// Actually write the error
		writeError(ctx, resp, rpcerr, hooks)
		// If possible, flush the error to the wire.
		f, ok := resp.(%s)
		if ok {
			f.Flush()
		}

		panic(r)
	}
}
`

var errFromPanicTPL = `
// errFromPanic returns the typed error if the recovered panic is an error, otherwise formats as error.
func errFromPanic(p interface{}) error {
	if err, ok := p.(error); ok {
		return err
	}
	return %s("panic: %%v", p)
}
`

var internalWithCauseTPL = `
// internalWithCause is a rpc Internal error wrapping an original error cause,
// but the original error message is not exposed on Msg(). The original error
// can be checked with go1.13+ errors.Is/As, and also by (github.com/pkg/errors).Unwrap
type internalWithCause struct {
	msg   string
	cause error
}

func (e *internalWithCause) Unwrap() error                               { return e.cause } // for go1.13 + errors.Is/As
func (e *internalWithCause) Cause() error                                { return e.cause } // for github.com/pkg/errors
func (e *internalWithCause) Error() string                               { return e.msg + ": " + e.cause.Error() }
func (e *internalWithCause) Code() %s                       { return %s }
func (e *internalWithCause) Msg() string                                 { return e.msg }
func (e *internalWithCause) Meta(key string) string                      { return "" }
func (e *internalWithCause) MetaMap() map[string]string                  { return nil }
func (e *internalWithCause) WithMeta(key string, val string) %s { return e }
`

var malformedRequestErrorTPL = `
// malformedRequestError is used when the rpc server cannot unmarshal a request
func malformedRequestError(msg string) %s {
	return %s(%s, msg)
}
`

var badRouteErrorTPL = `
// badRouteError is used when the hrpc server cannot route a request
func badRouteError(msg string, method, url string) %s {
	err := %s(%s, msg)
	err = err.WithMeta("hrpc_invalid_route", method+" "+url)
	return err
}
`
